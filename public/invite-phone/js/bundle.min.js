(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.Alpine = factory());
}(this, (function () {
  'use strict';

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {value: value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }

  function domReady() {
    return new Promise(resolve => {
      if (document.readyState == "loading") {
        document.addEventListener("DOMContentLoaded", resolve);
      } else {
        resolve();
      }
    });
  }

  function arrayUnique(array) {
    return Array.from(new Set(array));
  }

  function isTesting() {
    return navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom");
  }

  function warnIfMalformedTemplate(el, directive) {
    if (el.tagName.toLowerCase() !== 'template') {
      console.warn(`Alpine: [${directive}] directive should only be added to <template> tags. See https://github.com/alpinejs/alpine#${directive}`);
    } else if (el.content.childElementCount !== 1) {
      console.warn(`Alpine: <template> tag with [${directive}] encountered with multiple element roots. Make sure <template> only has a single child node.`);
    }
  }

  function kebabCase(subject) {
    return subject.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/[_\s]/, '-').toLowerCase();
  }

  function camelCase(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }

  function walk(el, callback) {
    if (callback(el) === false) return;
    let node = el.firstElementChild;
    while (node) {
      walk(node, callback);
      node = node.nextElementSibling;
    }
  }

  function debounce(func, wait) {
    var timeout;
    return function () {
      var context = this, args = arguments;
      var later = function later() {
        timeout = null;
        func.apply(context, args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  function saferEval(expression, dataContext, additionalHelperVariables = {}) {
    if (typeof expression === 'function') {
      return expression.call(dataContext);
    }
    return new Function(['$data', ...Object.keys(additionalHelperVariables)], `var __alpine_result; with($data) { __alpine_result = ${expression} }; return __alpine_result`)(dataContext, ...Object.values(additionalHelperVariables));
  }

  function saferEvalNoReturn(expression, dataContext, additionalHelperVariables = {}) {
    if (typeof expression === 'function') {
      return expression.call(dataContext, additionalHelperVariables['$event']);
    }
    if (Object.keys(dataContext).includes(expression)) {
      let methodReference = new Function(['dataContext', ...Object.keys(additionalHelperVariables)], `with(dataContext) { return ${expression} }`)(dataContext, ...Object.values(additionalHelperVariables));
      if (typeof methodReference === 'function') {
        return methodReference.call(dataContext, additionalHelperVariables['$event']);
      }
    }
    return new Function(['dataContext', ...Object.keys(additionalHelperVariables)], `with(dataContext) { ${expression} }`)(dataContext, ...Object.values(additionalHelperVariables));
  }

  const xAttrRE = /^x-(on|bind|data|text|html|model|if|for|show|cloak|transition|ref|spread)\b/;

  function isXAttr(attr) {
    const name = replaceAtAndColonWithStandardSyntax(attr.name);
    return xAttrRE.test(name);
  }

  function getXAttrs(el, component, type) {
    let directives = Array.from(el.attributes).filter(isXAttr).map(parseHtmlAttribute);
    let spreadDirective = directives.filter(directive => directive.type === 'spread')[0];
    if (spreadDirective) {
      let spreadObject = saferEval(spreadDirective.expression, component.$data);
      directives = directives.concat(Object.entries(spreadObject).map(([name, value]) => parseHtmlAttribute({
        name,
        value
      })));
    }
    if (type) return directives.filter(i => i.type === type);
    return sortDirectives(directives);
  }

  function sortDirectives(directives) {
    let directiveOrder = ['bind', 'model', 'show', 'catch-all'];
    return directives.sort((a, b) => {
      let typeA = directiveOrder.indexOf(a.type) === -1 ? 'catch-all' : a.type;
      let typeB = directiveOrder.indexOf(b.type) === -1 ? 'catch-all' : b.type;
      return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);
    });
  }

  function parseHtmlAttribute({name, value}) {
    const normalizedName = replaceAtAndColonWithStandardSyntax(name);
    const typeMatch = normalizedName.match(xAttrRE);
    const valueMatch = normalizedName.match(/:([a-zA-Z\-:]+)/);
    const modifiers = normalizedName.match(/\.[^.\]]+(?=[^\]]*$)/g) || [];
    return {
      type: typeMatch ? typeMatch[1] : null,
      value: valueMatch ? valueMatch[1] : null,
      modifiers: modifiers.map(i => i.replace('.', '')),
      expression: value
    };
  }

  function isBooleanAttr(attrName) {
    const booleanAttributes = ['disabled', 'checked', 'required', 'readonly', 'hidden', 'open', 'selected', 'autofocus', 'itemscope', 'multiple', 'novalidate', 'allowfullscreen', 'allowpaymentrequest', 'formnovalidate', 'autoplay', 'controls', 'loop', 'muted', 'playsinline', 'default', 'ismap', 'reversed', 'async', 'defer', 'nomodule'];
    return booleanAttributes.includes(attrName);
  }

  function replaceAtAndColonWithStandardSyntax(name) {
    if (name.startsWith('@')) {
      return name.replace('@', 'x-on:');
    } else if (name.startsWith(':')) {
      return name.replace(':', 'x-bind:');
    }
    return name;
  }

  function convertClassStringToArray(classList, filterFn = Boolean) {
    return classList.split(' ').filter(filterFn);
  }

  const TRANSITION_TYPE_IN = 'in';
  const TRANSITION_TYPE_OUT = 'out';

  function transitionIn(el, show, component, forceSkip = false) {
    if (forceSkip) return show();
    if (el.__x_transition && el.__x_transition.type === TRANSITION_TYPE_IN) {
      return;
    }
    const attrs = getXAttrs(el, component, 'transition');
    const showAttr = getXAttrs(el, component, 'show')[0];
    if (showAttr && showAttr.modifiers.includes('transition')) {
      let modifiers = showAttr.modifiers;
      if (modifiers.includes('out') && !modifiers.includes('in')) return show();
      const settingBothSidesOfTransition = modifiers.includes('in') && modifiers.includes('out');
      modifiers = settingBothSidesOfTransition ? modifiers.filter((i, index) => index < modifiers.indexOf('out')) : modifiers;
      transitionHelperIn(el, modifiers, show);
    } else if (attrs.some(attr => ['enter', 'enter-start', 'enter-end'].includes(attr.value))) {
      transitionClassesIn(el, component, attrs, show);
    } else {
      show();
    }
  }

  function transitionOut(el, hide, component, forceSkip = false) {
    if (forceSkip) return hide();
    if (el.__x_transition && el.__x_transition.type === TRANSITION_TYPE_OUT) {
      return;
    }
    const attrs = getXAttrs(el, component, 'transition');
    const showAttr = getXAttrs(el, component, 'show')[0];
    if (showAttr && showAttr.modifiers.includes('transition')) {
      let modifiers = showAttr.modifiers;
      if (modifiers.includes('in') && !modifiers.includes('out')) return hide();
      const settingBothSidesOfTransition = modifiers.includes('in') && modifiers.includes('out');
      modifiers = settingBothSidesOfTransition ? modifiers.filter((i, index) => index > modifiers.indexOf('out')) : modifiers;
      transitionHelperOut(el, modifiers, settingBothSidesOfTransition, hide);
    } else if (attrs.some(attr => ['leave', 'leave-start', 'leave-end'].includes(attr.value))) {
      transitionClassesOut(el, component, attrs, hide);
    } else {
      hide();
    }
  }

  function transitionHelperIn(el, modifiers, showCallback) {
    const styleValues = {
      duration: modifierValue(modifiers, 'duration', 150),
      origin: modifierValue(modifiers, 'origin', 'center'),
      first: {opacity: 0, scale: modifierValue(modifiers, 'scale', 95)},
      second: {opacity: 1, scale: 100}
    };
    transitionHelper(el, modifiers, showCallback, () => {
    }, styleValues, TRANSITION_TYPE_IN);
  }

  function transitionHelperOut(el, modifiers, settingBothSidesOfTransition, hideCallback) {
    const duration = settingBothSidesOfTransition ? modifierValue(modifiers, 'duration', 150) : modifierValue(modifiers, 'duration', 150) / 2;
    const styleValues = {
      duration: duration,
      origin: modifierValue(modifiers, 'origin', 'center'),
      first: {opacity: 1, scale: 100},
      second: {opacity: 0, scale: modifierValue(modifiers, 'scale', 95)}
    };
    transitionHelper(el, modifiers, () => {
    }, hideCallback, styleValues, TRANSITION_TYPE_OUT);
  }

  function modifierValue(modifiers, key, fallback) {
    if (modifiers.indexOf(key) === -1) return fallback;
    const rawValue = modifiers[modifiers.indexOf(key) + 1];
    if (!rawValue) return fallback;
    if (key === 'scale') {
      if (!isNumeric(rawValue)) return fallback;
    }
    if (key === 'duration') {
      let match = rawValue.match(/([0-9]+)ms/);
      if (match) return match[1];
    }
    if (key === 'origin') {
      if (['top', 'right', 'left', 'center', 'bottom'].includes(modifiers[modifiers.indexOf(key) + 2])) {
        return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(' ');
      }
    }
    return rawValue;
  }

  function transitionHelper(el, modifiers, hook1, hook2, styleValues, type) {
    if (el.__x_transition) {
      cancelAnimationFrame(el.__x_transition.nextFrame);
      el.__x_transition.callback && el.__x_transition.callback();
    }
    const opacityCache = el.style.opacity;
    const transformCache = el.style.transform;
    const transformOriginCache = el.style.transformOrigin;
    const noModifiers = !modifiers.includes('opacity') && !modifiers.includes('scale');
    const transitionOpacity = noModifiers || modifiers.includes('opacity');
    const transitionScale = noModifiers || modifiers.includes('scale');
    const stages = {
      start() {
        if (transitionOpacity) el.style.opacity = styleValues.first.opacity;
        if (transitionScale) el.style.transform = `scale(${styleValues.first.scale / 100})`;
      }, during() {
        if (transitionScale) el.style.transformOrigin = styleValues.origin;
        el.style.transitionProperty = [transitionOpacity ? `opacity` : ``, transitionScale ? `transform` : ``].join(' ').trim();
        el.style.transitionDuration = `${styleValues.duration / 1000}s`;
        el.style.transitionTimingFunction = `cubic-bezier(0.4, 0.0, 0.2, 1)`;
      }, show() {
        hook1();
      }, end() {
        if (transitionOpacity) el.style.opacity = styleValues.second.opacity;
        if (transitionScale) el.style.transform = `scale(${styleValues.second.scale / 100})`;
      }, hide() {
        hook2();
      }, cleanup() {
        if (transitionOpacity) el.style.opacity = opacityCache;
        if (transitionScale) el.style.transform = transformCache;
        if (transitionScale) el.style.transformOrigin = transformOriginCache;
        el.style.transitionProperty = null;
        el.style.transitionDuration = null;
        el.style.transitionTimingFunction = null;
      }
    };
    transition(el, stages, type);
  }

  function transitionClassesIn(el, component, directives, showCallback) {
    let ensureStringExpression = expression => {
      return typeof expression === 'function' ? component.evaluateReturnExpression(el, expression) : expression;
    };
    const enter = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter') || {expression: ''}).expression));
    const enterStart = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter-start') || {expression: ''}).expression));
    const enterEnd = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter-end') || {expression: ''}).expression));
    transitionClasses(el, enter, enterStart, enterEnd, showCallback, () => {
    }, TRANSITION_TYPE_IN);
  }

  function transitionClassesOut(el, component, directives, hideCallback) {
    const leave = convertClassStringToArray((directives.find(i => i.value === 'leave') || {expression: ''}).expression);
    const leaveStart = convertClassStringToArray((directives.find(i => i.value === 'leave-start') || {expression: ''}).expression);
    const leaveEnd = convertClassStringToArray((directives.find(i => i.value === 'leave-end') || {expression: ''}).expression);
    transitionClasses(el, leave, leaveStart, leaveEnd, () => {
    }, hideCallback, TRANSITION_TYPE_OUT);
  }

  function transitionClasses(el, classesDuring, classesStart, classesEnd, hook1, hook2, type) {
    if (el.__x_transition) {
      cancelAnimationFrame(el.__x_transition.nextFrame);
      el.__x_transition.callback && el.__x_transition.callback();
    }
    const originalClasses = el.__x_original_classes || [];
    const stages = {
      start() {
        el.classList.add(...classesStart);
      }, during() {
        el.classList.add(...classesDuring);
      }, show() {
        hook1();
      }, end() {
        el.classList.remove(...classesStart.filter(i => !originalClasses.includes(i)));
        el.classList.add(...classesEnd);
      }, hide() {
        hook2();
      }, cleanup() {
        el.classList.remove(...classesDuring.filter(i => !originalClasses.includes(i)));
        el.classList.remove(...classesEnd.filter(i => !originalClasses.includes(i)));
      }
    };
    transition(el, stages, type);
  }

  function transition(el, stages, type) {
    el.__x_transition = {
      type: type, callback: once(() => {
        stages.hide();
        if (el.isConnected) {
          stages.cleanup();
        }
        delete el.__x_transition;
      }), nextFrame: null
    };
    stages.start();
    stages.during();
    el.__x_transition.nextFrame = requestAnimationFrame(() => {
      let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, '').replace('s', '')) * 1000;
      if (duration === 0) {
        duration = Number(getComputedStyle(el).animationDuration.replace('s', '')) * 1000;
      }
      stages.show();
      el.__x_transition.nextFrame = requestAnimationFrame(() => {
        stages.end();
        setTimeout(el.__x_transition.callback, duration);
      });
    });
  }

  function isNumeric(subject) {
    return !isNaN(subject);
  }

  function once(callback) {
    let called = false;
    return function () {
      if (!called) {
        called = true;
        callback.apply(this, arguments);
      }
    };
  }

  function handleForDirective(component, templateEl, expression, initialUpdate, extraVars) {
    warnIfMalformedTemplate(templateEl, 'x-for');
    let iteratorNames = typeof expression === 'function' ? parseForExpression(component.evaluateReturnExpression(templateEl, expression)) : parseForExpression(expression);
    let items = evaluateItemsAndReturnEmptyIfXIfIsPresentAndFalseOnElement(component, templateEl, iteratorNames, extraVars);
    let currentEl = templateEl;
    items.forEach((item, index) => {
      let iterationScopeVariables = getIterationScopeVariables(iteratorNames, item, index, items, extraVars());
      let currentKey = generateKeyForIteration(component, templateEl, index, iterationScopeVariables);
      let nextEl = lookAheadForMatchingKeyedElementAndMoveItIfFound(currentEl.nextElementSibling, currentKey);
      if (!nextEl) {
        nextEl = addElementInLoopAfterCurrentEl(templateEl, currentEl);
        transitionIn(nextEl, () => {
        }, component, initialUpdate);
        nextEl.__x_for = iterationScopeVariables;
        component.initializeElements(nextEl, () => nextEl.__x_for);
      } else {
        delete nextEl.__x_for_key;
        nextEl.__x_for = iterationScopeVariables;
        component.updateElements(nextEl, () => nextEl.__x_for);
      }
      currentEl = nextEl;
      currentEl.__x_for_key = currentKey;
    });
    removeAnyLeftOverElementsFromPreviousUpdate(currentEl, component);
  }

  function parseForExpression(expression) {
    let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    let stripParensRE = /^\(|\)$/g;
    let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    let inMatch = expression.match(forAliasRE);
    if (!inMatch) return;
    let res = {};
    res.items = inMatch[2].trim();
    let item = inMatch[1].trim().replace(stripParensRE, '');
    let iteratorMatch = item.match(forIteratorRE);
    if (iteratorMatch) {
      res.item = item.replace(forIteratorRE, '').trim();
      res.index = iteratorMatch[1].trim();
      if (iteratorMatch[2]) {
        res.collection = iteratorMatch[2].trim();
      }
    } else {
      res.item = item;
    }
    return res;
  }

  function getIterationScopeVariables(iteratorNames, item, index, items, extraVars) {
    let scopeVariables = extraVars ? _objectSpread2({}, extraVars) : {};
    scopeVariables[iteratorNames.item] = item;
    if (iteratorNames.index) scopeVariables[iteratorNames.index] = index;
    if (iteratorNames.collection) scopeVariables[iteratorNames.collection] = items;
    return scopeVariables;
  }

  function generateKeyForIteration(component, el, index, iterationScopeVariables) {
    let bindKeyAttribute = getXAttrs(el, component, 'bind').filter(attr => attr.value === 'key')[0];
    if (!bindKeyAttribute) return index;
    return component.evaluateReturnExpression(el, bindKeyAttribute.expression, () => iterationScopeVariables);
  }

  function evaluateItemsAndReturnEmptyIfXIfIsPresentAndFalseOnElement(component, el, iteratorNames, extraVars) {
    let ifAttribute = getXAttrs(el, component, 'if')[0];
    if (ifAttribute && !component.evaluateReturnExpression(el, ifAttribute.expression)) {
      return [];
    }
    return component.evaluateReturnExpression(el, iteratorNames.items, extraVars);
  }

  function addElementInLoopAfterCurrentEl(templateEl, currentEl) {
    let clone = document.importNode(templateEl.content, true);
    currentEl.parentElement.insertBefore(clone, currentEl.nextElementSibling);
    return currentEl.nextElementSibling;
  }

  function lookAheadForMatchingKeyedElementAndMoveItIfFound(nextEl, currentKey) {
    if (!nextEl) return;
    if (nextEl.__x_for_key === currentKey) return nextEl;
    let tmpNextEl = nextEl;
    while (tmpNextEl) {
      if (tmpNextEl.__x_for_key === currentKey) {
        return tmpNextEl.parentElement.insertBefore(tmpNextEl, nextEl);
      }
      tmpNextEl = tmpNextEl.nextElementSibling && tmpNextEl.nextElementSibling.__x_for_key !== undefined ? tmpNextEl.nextElementSibling : false;
    }
  }

  function removeAnyLeftOverElementsFromPreviousUpdate(currentEl, component) {
    var nextElementFromOldLoop = currentEl.nextElementSibling && currentEl.nextElementSibling.__x_for_key !== undefined ? currentEl.nextElementSibling : false;
    while (nextElementFromOldLoop) {
      let nextElementFromOldLoopImmutable = nextElementFromOldLoop;
      let nextSibling = nextElementFromOldLoop.nextElementSibling;
      transitionOut(nextElementFromOldLoop, () => {
        nextElementFromOldLoopImmutable.remove();
      }, component);
      nextElementFromOldLoop = nextSibling && nextSibling.__x_for_key !== undefined ? nextSibling : false;
    }
  }

  function handleAttributeBindingDirective(component, el, attrName, expression, extraVars, attrType, modifiers) {
    var value = component.evaluateReturnExpression(el, expression, extraVars);
    if (attrName === 'value') {
      if (value === undefined && expression.match(/\./).length) {
        value = '';
      }
      if (el.type === 'radio') {
        if (el.attributes.value === undefined && attrType === 'bind') {
          el.value = value;
        } else if (attrType !== 'bind') {
          el.checked = el.value == value;
        }
      } else if (el.type === 'checkbox') {
        if (typeof value === 'string' && attrType === 'bind') {
          el.value = value;
        } else if (attrType !== 'bind') {
          if (Array.isArray(value)) {
            el.checked = value.some(val => val == el.value);
          } else {
            el.checked = !!value;
          }
        }
      } else if (el.tagName === 'SELECT') {
        updateSelect(el, value);
      } else {
        if (el.value === value) return;
        el.value = value;
      }
    } else if (attrName === 'class') {
      if (Array.isArray(value)) {
        const originalClasses = el.__x_original_classes || [];
        el.setAttribute('class', arrayUnique(originalClasses.concat(value)).join(' '));
      } else if (typeof value === 'object') {
        const keysSortedByBooleanValue = Object.keys(value).sort((a, b) => value[a] - value[b]);
        keysSortedByBooleanValue.forEach(classNames => {
          if (value[classNames]) {
            convertClassStringToArray(classNames).forEach(className => el.classList.add(className));
          } else {
            convertClassStringToArray(classNames).forEach(className => el.classList.remove(className));
          }
        });
      } else {
        const originalClasses = el.__x_original_classes || [];
        const newClasses = convertClassStringToArray(value);
        el.setAttribute('class', arrayUnique(originalClasses.concat(newClasses)).join(' '));
      }
    } else {
      attrName = modifiers.includes('camel') ? camelCase(attrName) : attrName;
      if ([null, undefined, false].includes(value)) {
        el.removeAttribute(attrName);
      } else {
        isBooleanAttr(attrName) ? setIfChanged(el, attrName, attrName) : setIfChanged(el, attrName, value);
      }
    }
  }

  function setIfChanged(el, attrName, value) {
    if (el.getAttribute(attrName) != value) {
      el.setAttribute(attrName, value);
    }
  }

  function updateSelect(el, value) {
    const arrayWrappedValue = [].concat(value).map(value => {
      return value + '';
    });
    Array.from(el.options).forEach(option => {
      option.selected = arrayWrappedValue.includes(option.value || option.text);
    });
  }

  function handleTextDirective(el, output, expression) {
    if (output === undefined && expression.match(/\./)) {
      output = '';
    }
    el.innerText = output;
  }

  function handleHtmlDirective(component, el, expression, extraVars) {
    el.innerHTML = component.evaluateReturnExpression(el, expression, extraVars);
  }

  function handleShowDirective(component, el, value, modifiers, initialUpdate = false) {
    const hide = () => {
      el.style.display = 'none';
    };
    const show = () => {
      if (el.style.length === 1 && el.style.display === 'none') {
        el.removeAttribute('style');
      } else {
        el.style.removeProperty('display');
      }
    };
    if (initialUpdate === true) {
      if (value) {
        show();
      } else {
        hide();
      }
      return;
    }
    const handle = resolve => {
      if (value) {
        if (el.style.display === 'none' || el.__x_transition) {
          transitionIn(el, () => {
            show();
          }, component);
        }
        resolve(() => {
        });
      } else {
        if (el.style.display !== 'none') {
          transitionOut(el, () => {
            resolve(() => {
              hide();
            });
          }, component);
        } else {
          resolve(() => {
          });
        }
      }
    };
    if (modifiers.includes('immediate')) {
      handle(finish => finish());
      return;
    }
    if (component.showDirectiveLastElement && !component.showDirectiveLastElement.contains(el)) {
      component.executeAndClearRemainingShowDirectiveStack();
    }
    component.showDirectiveStack.push(handle);
    component.showDirectiveLastElement = el;
  }

  function handleIfDirective(component, el, expressionResult, initialUpdate, extraVars) {
    warnIfMalformedTemplate(el, 'x-if');
    const elementHasAlreadyBeenAdded = el.nextElementSibling && el.nextElementSibling.__x_inserted_me === true;
    if (expressionResult && (!elementHasAlreadyBeenAdded || el.__x_transition)) {
      const clone = document.importNode(el.content, true);
      el.parentElement.insertBefore(clone, el.nextElementSibling);
      transitionIn(el.nextElementSibling, () => {
      }, component, initialUpdate);
      component.initializeElements(el.nextElementSibling, extraVars);
      el.nextElementSibling.__x_inserted_me = true;
    } else if (!expressionResult && elementHasAlreadyBeenAdded) {
      transitionOut(el.nextElementSibling, () => {
        el.nextElementSibling.remove();
      }, component, initialUpdate);
    }
  }

  function registerListener(component, el, event, modifiers, expression, extraVars = {}) {
    const options = {passive: modifiers.includes('passive')};
    if (modifiers.includes('camel')) {
      event = camelCase(event);
    }
    if (modifiers.includes('away')) {
      let handler = e => {
        if (el.contains(e.target)) return;
        if (el.offsetWidth < 1 && el.offsetHeight < 1) return;
        runListenerHandler(component, expression, e, extraVars);
        if (modifiers.includes('once')) {
          document.removeEventListener(event, handler, options);
        }
      };
      document.addEventListener(event, handler, options);
    } else {
      let listenerTarget = modifiers.includes('window') ? window : modifiers.includes('document') ? document : el;
      let handler = e => {
        if (listenerTarget === window || listenerTarget === document) {
          if (!document.body.contains(el)) {
            listenerTarget.removeEventListener(event, handler, options);
            return;
          }
        }
        if (isKeyEvent(event)) {
          if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {
            return;
          }
        }
        if (modifiers.includes('prevent')) e.preventDefault();
        if (modifiers.includes('stop')) e.stopPropagation();
        if (!modifiers.includes('self') || e.target === el) {
          const returnValue = runListenerHandler(component, expression, e, extraVars);
          if (returnValue === false) {
            e.preventDefault();
          } else {
            if (modifiers.includes('once')) {
              listenerTarget.removeEventListener(event, handler, options);
            }
          }
        }
      };
      if (modifiers.includes('debounce')) {
        let nextModifier = modifiers[modifiers.indexOf('debounce') + 1] || 'invalid-wait';
        let wait = isNumeric(nextModifier.split('ms')[0]) ? Number(nextModifier.split('ms')[0]) : 250;
        handler = debounce(handler, wait);
      }
      listenerTarget.addEventListener(event, handler, options);
    }
  }

  function runListenerHandler(component, expression, e, extraVars) {
    return component.evaluateCommandExpression(e.target, expression, () => {
      return _objectSpread2(_objectSpread2({}, extraVars()), {}, {'$event': e});
    });
  }

  function isKeyEvent(event) {
    return ['keydown', 'keyup'].includes(event);
  }

  function isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {
    let keyModifiers = modifiers.filter(i => {
      return !['window', 'document', 'prevent', 'stop'].includes(i);
    });
    if (keyModifiers.includes('debounce')) {
      let debounceIndex = keyModifiers.indexOf('debounce');
      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || 'invalid-wait').split('ms')[0]) ? 2 : 1);
    }
    if (keyModifiers.length === 0) return false;
    if (keyModifiers.length === 1 && keyModifiers[0] === keyToModifier(e.key)) return false;
    const systemKeyModifiers = ['ctrl', 'shift', 'alt', 'meta', 'cmd', 'super'];
    const selectedSystemKeyModifiers = systemKeyModifiers.filter(modifier => keyModifiers.includes(modifier));
    keyModifiers = keyModifiers.filter(i => !selectedSystemKeyModifiers.includes(i));
    if (selectedSystemKeyModifiers.length > 0) {
      const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter(modifier => {
        if (modifier === 'cmd' || modifier === 'super') modifier = 'meta';
        return e[`${modifier}Key`];
      });
      if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {
        if (keyModifiers[0] === keyToModifier(e.key)) return false;
      }
    }
    return true;
  }

  function keyToModifier(key) {
    switch (key) {
      case '/':
        return 'slash';
      case ' ':
      case 'Spacebar':
        return 'space';
      default:
        return key && kebabCase(key);
    }
  }

  function registerModelListener(component, el, modifiers, expression, extraVars) {
    var event = el.tagName.toLowerCase() === 'select' || ['checkbox', 'radio'].includes(el.type) || modifiers.includes('lazy') ? 'change' : 'input';
    const listenerExpression = `${expression} = rightSideOfExpression($event, ${expression})`;
    registerListener(component, el, event, modifiers, listenerExpression, () => {
      return _objectSpread2(_objectSpread2({}, extraVars()), {}, {rightSideOfExpression: generateModelAssignmentFunction(el, modifiers, expression)});
    });
  }

  function generateModelAssignmentFunction(el, modifiers, expression) {
    if (el.type === 'radio') {
      if (!el.hasAttribute('name')) el.setAttribute('name', expression);
    }
    return (event, currentValue) => {
      if (event instanceof CustomEvent && event.detail) {
        return event.detail;
      } else if (el.type === 'checkbox') {
        if (Array.isArray(currentValue)) {
          const newValue = modifiers.includes('number') ? safeParseNumber(event.target.value) : event.target.value;
          return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter(i => i !== newValue);
        } else {
          return event.target.checked;
        }
      } else if (el.tagName.toLowerCase() === 'select' && el.multiple) {
        return modifiers.includes('number') ? Array.from(event.target.selectedOptions).map(option => {
          const rawValue = option.value || option.text;
          return safeParseNumber(rawValue);
        }) : Array.from(event.target.selectedOptions).map(option => {
          return option.value || option.text;
        });
      } else {
        const rawValue = event.target.value;
        return modifiers.includes('number') ? safeParseNumber(rawValue) : modifiers.includes('trim') ? rawValue.trim() : rawValue;
      }
    };
  }

  function safeParseNumber(rawValue) {
    const number = rawValue ? parseFloat(rawValue) : null;
    return isNumeric(number) ? number : rawValue;
  }

  const {isArray} = Array;
  const {getPrototypeOf, create: ObjectCreate, defineProperty: ObjectDefineProperty, defineProperties: ObjectDefineProperties, isExtensible, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols, preventExtensions, hasOwnProperty,} = Object;
  const {push: ArrayPush, concat: ArrayConcat, map: ArrayMap,} = Array.prototype;

  function isUndefined(obj) {
    return obj === undefined;
  }

  function isFunction(obj) {
    return typeof obj === 'function';
  }

  function isObject(obj) {
    return typeof obj === 'object';
  }

  const proxyToValueMap = new WeakMap();

  function registerProxy(proxy, value) {
    proxyToValueMap.set(proxy, value);
  }

  const unwrap = (replicaOrAny) => proxyToValueMap.get(replicaOrAny) || replicaOrAny;

  function wrapValue(membrane, value) {
    return membrane.valueIsObservable(value) ? membrane.getProxy(value) : value;
  }

  function unwrapDescriptor(descriptor) {
    if (hasOwnProperty.call(descriptor, 'value')) {
      descriptor.value = unwrap(descriptor.value);
    }
    return descriptor;
  }

  function lockShadowTarget(membrane, shadowTarget, originalTarget) {
    const targetKeys = ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
    targetKeys.forEach((key) => {
      let descriptor = getOwnPropertyDescriptor(originalTarget, key);
      if (!descriptor.configurable) {
        descriptor = wrapDescriptor(membrane, descriptor, wrapValue);
      }
      ObjectDefineProperty(shadowTarget, key, descriptor);
    });
    preventExtensions(shadowTarget);
  }

  class ReactiveProxyHandler {
    constructor(membrane, value) {
      this.originalTarget = value;
      this.membrane = membrane;
    }

    get(shadowTarget, key) {
      const {originalTarget, membrane} = this;
      const value = originalTarget[key];
      const {valueObserved} = membrane;
      valueObserved(originalTarget, key);
      return membrane.getProxy(value);
    }

    set(shadowTarget, key, value) {
      const {originalTarget, membrane: {valueMutated}} = this;
      const oldValue = originalTarget[key];
      if (oldValue !== value) {
        originalTarget[key] = value;
        valueMutated(originalTarget, key);
      } else if (key === 'length' && isArray(originalTarget)) {
        valueMutated(originalTarget, key);
      }
      return true;
    }

    deleteProperty(shadowTarget, key) {
      const {originalTarget, membrane: {valueMutated}} = this;
      delete originalTarget[key];
      valueMutated(originalTarget, key);
      return true;
    }

    apply(shadowTarget, thisArg, argArray) {
    }

    construct(target, argArray, newTarget) {
    }

    has(shadowTarget, key) {
      const {originalTarget, membrane: {valueObserved}} = this;
      valueObserved(originalTarget, key);
      return key in originalTarget;
    }

    ownKeys(shadowTarget) {
      const {originalTarget} = this;
      return ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
    }

    isExtensible(shadowTarget) {
      const shadowIsExtensible = isExtensible(shadowTarget);
      if (!shadowIsExtensible) {
        return shadowIsExtensible;
      }
      const {originalTarget, membrane} = this;
      const targetIsExtensible = isExtensible(originalTarget);
      if (!targetIsExtensible) {
        lockShadowTarget(membrane, shadowTarget, originalTarget);
      }
      return targetIsExtensible;
    }

    setPrototypeOf(shadowTarget, prototype) {
    }

    getPrototypeOf(shadowTarget) {
      const {originalTarget} = this;
      return getPrototypeOf(originalTarget);
    }

    getOwnPropertyDescriptor(shadowTarget, key) {
      const {originalTarget, membrane} = this;
      const {valueObserved} = this.membrane;
      valueObserved(originalTarget, key);
      let desc = getOwnPropertyDescriptor(originalTarget, key);
      if (isUndefined(desc)) {
        return desc;
      }
      const shadowDescriptor = getOwnPropertyDescriptor(shadowTarget, key);
      if (!isUndefined(shadowDescriptor)) {
        return shadowDescriptor;
      }
      desc = wrapDescriptor(membrane, desc, wrapValue);
      if (!desc.configurable) {
        ObjectDefineProperty(shadowTarget, key, desc);
      }
      return desc;
    }

    preventExtensions(shadowTarget) {
      const {originalTarget, membrane} = this;
      lockShadowTarget(membrane, shadowTarget, originalTarget);
      preventExtensions(originalTarget);
      return true;
    }

    defineProperty(shadowTarget, key, descriptor) {
      const {originalTarget, membrane} = this;
      const {valueMutated} = membrane;
      const {configurable} = descriptor;
      if (hasOwnProperty.call(descriptor, 'writable') && !hasOwnProperty.call(descriptor, 'value')) {
        const originalDescriptor = getOwnPropertyDescriptor(originalTarget, key);
        descriptor.value = originalDescriptor.value;
      }
      ObjectDefineProperty(originalTarget, key, unwrapDescriptor(descriptor));
      if (configurable === false) {
        ObjectDefineProperty(shadowTarget, key, wrapDescriptor(membrane, descriptor, wrapValue));
      }
      valueMutated(originalTarget, key);
      return true;
    }
  }

  function wrapReadOnlyValue(membrane, value) {
    return membrane.valueIsObservable(value) ? membrane.getReadOnlyProxy(value) : value;
  }

  class ReadOnlyHandler {
    constructor(membrane, value) {
      this.originalTarget = value;
      this.membrane = membrane;
    }

    get(shadowTarget, key) {
      const {membrane, originalTarget} = this;
      const value = originalTarget[key];
      const {valueObserved} = membrane;
      valueObserved(originalTarget, key);
      return membrane.getReadOnlyProxy(value);
    }

    set(shadowTarget, key, value) {
      return false;
    }

    deleteProperty(shadowTarget, key) {
      return false;
    }

    apply(shadowTarget, thisArg, argArray) {
    }

    construct(target, argArray, newTarget) {
    }

    has(shadowTarget, key) {
      const {originalTarget, membrane: {valueObserved}} = this;
      valueObserved(originalTarget, key);
      return key in originalTarget;
    }

    ownKeys(shadowTarget) {
      const {originalTarget} = this;
      return ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
    }

    setPrototypeOf(shadowTarget, prototype) {
    }

    getOwnPropertyDescriptor(shadowTarget, key) {
      const {originalTarget, membrane} = this;
      const {valueObserved} = membrane;
      valueObserved(originalTarget, key);
      let desc = getOwnPropertyDescriptor(originalTarget, key);
      if (isUndefined(desc)) {
        return desc;
      }
      const shadowDescriptor = getOwnPropertyDescriptor(shadowTarget, key);
      if (!isUndefined(shadowDescriptor)) {
        return shadowDescriptor;
      }
      desc = wrapDescriptor(membrane, desc, wrapReadOnlyValue);
      if (hasOwnProperty.call(desc, 'set')) {
        desc.set = undefined;
      }
      if (!desc.configurable) {
        ObjectDefineProperty(shadowTarget, key, desc);
      }
      return desc;
    }

    preventExtensions(shadowTarget) {
      return false;
    }

    defineProperty(shadowTarget, key, descriptor) {
      return false;
    }
  }

  function createShadowTarget(value) {
    let shadowTarget = undefined;
    if (isArray(value)) {
      shadowTarget = [];
    } else if (isObject(value)) {
      shadowTarget = {};
    }
    return shadowTarget;
  }

  const ObjectDotPrototype = Object.prototype;

  function defaultValueIsObservable(value) {
    if (value === null) {
      return false;
    }
    if (typeof value !== 'object') {
      return false;
    }
    if (isArray(value)) {
      return true;
    }
    const proto = getPrototypeOf(value);
    return (proto === ObjectDotPrototype || proto === null || getPrototypeOf(proto) === null);
  }

  const defaultValueObserved = (obj, key) => {
  };
  const defaultValueMutated = (obj, key) => {
  };
  const defaultValueDistortion = (value) => value;

  function wrapDescriptor(membrane, descriptor, getValue) {
    const {set, get} = descriptor;
    if (hasOwnProperty.call(descriptor, 'value')) {
      descriptor.value = getValue(membrane, descriptor.value);
    } else {
      if (!isUndefined(get)) {
        descriptor.get = function () {
          return getValue(membrane, get.call(unwrap(this)));
        };
      }
      if (!isUndefined(set)) {
        descriptor.set = function (value) {
          set.call(unwrap(this), membrane.unwrapProxy(value));
        };
      }
    }
    return descriptor;
  }

  class ReactiveMembrane {
    constructor(options) {
      this.valueDistortion = defaultValueDistortion;
      this.valueMutated = defaultValueMutated;
      this.valueObserved = defaultValueObserved;
      this.valueIsObservable = defaultValueIsObservable;
      this.objectGraph = new WeakMap();
      if (!isUndefined(options)) {
        const {valueDistortion, valueMutated, valueObserved, valueIsObservable} = options;
        this.valueDistortion = isFunction(valueDistortion) ? valueDistortion : defaultValueDistortion;
        this.valueMutated = isFunction(valueMutated) ? valueMutated : defaultValueMutated;
        this.valueObserved = isFunction(valueObserved) ? valueObserved : defaultValueObserved;
        this.valueIsObservable = isFunction(valueIsObservable) ? valueIsObservable : defaultValueIsObservable;
      }
    }

    getProxy(value) {
      const unwrappedValue = unwrap(value);
      const distorted = this.valueDistortion(unwrappedValue);
      if (this.valueIsObservable(distorted)) {
        const o = this.getReactiveState(unwrappedValue, distorted);
        return o.readOnly === value ? value : o.reactive;
      }
      return distorted;
    }

    getReadOnlyProxy(value) {
      value = unwrap(value);
      const distorted = this.valueDistortion(value);
      if (this.valueIsObservable(distorted)) {
        return this.getReactiveState(value, distorted).readOnly;
      }
      return distorted;
    }

    unwrapProxy(p) {
      return unwrap(p);
    }

    getReactiveState(value, distortedValue) {
      const {objectGraph,} = this;
      let reactiveState = objectGraph.get(distortedValue);
      if (reactiveState) {
        return reactiveState;
      }
      const membrane = this;
      reactiveState = {
        get reactive() {
          const reactiveHandler = new ReactiveProxyHandler(membrane, distortedValue);
          const proxy = new Proxy(createShadowTarget(distortedValue), reactiveHandler);
          registerProxy(proxy, value);
          ObjectDefineProperty(this, 'reactive', {value: proxy});
          return proxy;
        }, get readOnly() {
          const readOnlyHandler = new ReadOnlyHandler(membrane, distortedValue);
          const proxy = new Proxy(createShadowTarget(distortedValue), readOnlyHandler);
          registerProxy(proxy, value);
          ObjectDefineProperty(this, 'readOnly', {value: proxy});
          return proxy;
        }
      };
      objectGraph.set(distortedValue, reactiveState);
      return reactiveState;
    }
  }

  function wrap(data, mutationCallback) {
    let membrane = new ReactiveMembrane({
      valueMutated(target, key) {
        mutationCallback(target, key);
      }
    });
    return {data: membrane.getProxy(data), membrane: membrane};
  }

  function unwrap$1(membrane, observable) {
    let unwrappedData = membrane.unwrapProxy(observable);
    let copy = {};
    Object.keys(unwrappedData).forEach(key => {
      if (['$el', '$refs', '$nextTick', '$watch'].includes(key)) return;
      copy[key] = unwrappedData[key];
    });
    return copy;
  }

  class Component {
    constructor(el, componentForClone = null) {
      this.$el = el;
      const dataAttr = this.$el.getAttribute('x-data');
      const dataExpression = dataAttr === '' ? '{}' : dataAttr;
      const initExpression = this.$el.getAttribute('x-init');
      this.unobservedData = componentForClone ? componentForClone.getUnobservedData() : saferEval(dataExpression, {$el: this.$el});
      let {membrane, data} = this.wrapDataInObservable(this.unobservedData);
      this.$data = data;
      this.membrane = membrane;
      this.unobservedData.$el = this.$el;
      this.unobservedData.$refs = this.getRefsProxy();
      this.nextTickStack = [];
      this.unobservedData.$nextTick = callback => {
        this.nextTickStack.push(callback);
      };
      this.watchers = {};
      this.unobservedData.$watch = (property, callback) => {
        if (!this.watchers[property]) this.watchers[property] = [];
        this.watchers[property].push(callback);
      };
      let canonicalComponentElementReference = componentForClone ? componentForClone.$el : this.$el;
      Object.entries(Alpine.magicProperties).forEach(([name, callback]) => {
        Object.defineProperty(this.unobservedData, `$${name}`, {
          get: function get() {
            return callback(canonicalComponentElementReference);
          }
        });
      });
      this.showDirectiveStack = [];
      this.showDirectiveLastElement;
      var initReturnedCallback;
      if (initExpression && !componentForClone) {
        this.pauseReactivity = true;
        initReturnedCallback = this.evaluateReturnExpression(this.$el, initExpression);
        this.pauseReactivity = false;
      }
      this.initializeElements(this.$el);
      this.listenForNewElementsToInitialize();
      if (typeof initReturnedCallback === 'function') {
        initReturnedCallback.call(this.$data);
      }
      componentForClone || setTimeout(() => {
        Alpine.onComponentInitializeds.forEach(callback => callback(this));
      }, 0);
    }

    getUnobservedData() {
      return unwrap$1(this.membrane, this.$data);
    }

    wrapDataInObservable(data) {
      var self = this;
      let updateDom = debounce(function () {
        self.updateElements(self.$el);
      }, 0);
      return wrap(data, (target, key) => {
        if (self.watchers[key]) {
          self.watchers[key].forEach(callback => callback(target[key]));
        } else {
          Object.keys(self.watchers).filter(i => i.includes('.')).forEach(fullDotNotationKey => {
            let dotNotationParts = fullDotNotationKey.split('.');
            if (key !== dotNotationParts[dotNotationParts.length - 1]) return;
            dotNotationParts.reduce((comparisonData, part) => {
              if (Object.is(target, comparisonData)) {
                self.watchers[fullDotNotationKey].forEach(callback => callback(target[key]));
              }
              return comparisonData[part];
            }, self.getUnobservedData());
          });
        }
        if (self.pauseReactivity) return;
        updateDom();
      });
    }

    walkAndSkipNestedComponents(el, callback, initializeComponentCallback = () => {
    }) {
      walk(el, el => {
        if (el.hasAttribute('x-data')) {
          if (!el.isSameNode(this.$el)) {
            if (!el.__x) initializeComponentCallback(el);
            return false;
          }
        }
        return callback(el);
      });
    }

    initializeElements(rootEl, extraVars = () => {
    }) {
      this.walkAndSkipNestedComponents(rootEl, el => {
        if (el.__x_for_key !== undefined) return false;
        if (el.__x_inserted_me !== undefined) return false;
        this.initializeElement(el, extraVars);
      }, el => {
        el.__x = new Component(el);
      });
      this.executeAndClearRemainingShowDirectiveStack();
      this.executeAndClearNextTickStack(rootEl);
    }

    initializeElement(el, extraVars) {
      if (el.hasAttribute('class') && getXAttrs(el, this).length > 0) {
        el.__x_original_classes = convertClassStringToArray(el.getAttribute('class'));
      }
      this.registerListeners(el, extraVars);
      this.resolveBoundAttributes(el, true, extraVars);
    }

    updateElements(rootEl, extraVars = () => {
    }) {
      this.walkAndSkipNestedComponents(rootEl, el => {
        if (el.__x_for_key !== undefined && !el.isSameNode(this.$el)) return false;
        this.updateElement(el, extraVars);
      }, el => {
        el.__x = new Component(el);
      });
      this.executeAndClearRemainingShowDirectiveStack();
      this.executeAndClearNextTickStack(rootEl);
    }

    executeAndClearNextTickStack(el) {
      if (el === this.$el && this.nextTickStack.length > 0) {
        requestAnimationFrame(() => {
          while (this.nextTickStack.length > 0) {
            this.nextTickStack.shift()();
          }
        });
      }
    }

    executeAndClearRemainingShowDirectiveStack() {
      this.showDirectiveStack.reverse().map(thing => {
        return new Promise(resolve => {
          thing(finish => {
            resolve(finish);
          });
        });
      }).reduce((nestedPromise, promise) => {
        return nestedPromise.then(() => {
          return promise.then(finish => finish());
        });
      }, Promise.resolve(() => {
      }));
      this.showDirectiveStack = [];
      this.showDirectiveLastElement = undefined;
    }

    updateElement(el, extraVars) {
      this.resolveBoundAttributes(el, false, extraVars);
    }

    registerListeners(el, extraVars) {
      getXAttrs(el, this).forEach(({type, value, modifiers, expression}) => {
        switch (type) {
          case 'on':
            registerListener(this, el, value, modifiers, expression, extraVars);
            break;
          case 'model':
            registerModelListener(this, el, modifiers, expression, extraVars);
            break;
        }
      });
    }

    resolveBoundAttributes(el, initialUpdate = false, extraVars) {
      let attrs = getXAttrs(el, this);
      if (el.type !== undefined && el.type === 'radio') {
        const modelIdx = attrs.findIndex(attr => attr.type === 'model');
        if (modelIdx > -1) {
          attrs.push(attrs.splice(modelIdx, 1)[0]);
        }
      }
      attrs.forEach(({type, value, modifiers, expression}) => {
        switch (type) {
          case 'model':
            handleAttributeBindingDirective(this, el, 'value', expression, extraVars, type, modifiers);
            break;
          case 'bind':
            if (el.tagName.toLowerCase() === 'template' && value === 'key') return;
            handleAttributeBindingDirective(this, el, value, expression, extraVars, type, modifiers);
            break;
          case 'text':
            var output = this.evaluateReturnExpression(el, expression, extraVars);
            handleTextDirective(el, output, expression);
            break;
          case 'html':
            handleHtmlDirective(this, el, expression, extraVars);
            break;
          case 'show':
            var output = this.evaluateReturnExpression(el, expression, extraVars);
            handleShowDirective(this, el, output, modifiers, initialUpdate);
            break;
          case 'if':
            if (attrs.some(i => i.type === 'for')) return;
            var output = this.evaluateReturnExpression(el, expression, extraVars);
            handleIfDirective(this, el, output, initialUpdate, extraVars);
            break;
          case 'for':
            handleForDirective(this, el, expression, initialUpdate, extraVars);
            break;
          case 'cloak':
            el.removeAttribute('x-cloak');
            break;
        }
      });
    }

    evaluateReturnExpression(el, expression, extraVars = () => {
    }) {
      return saferEval(expression, this.$data, _objectSpread2(_objectSpread2({}, extraVars()), {}, {$dispatch: this.getDispatchFunction(el)}));
    }

    evaluateCommandExpression(el, expression, extraVars = () => {
    }) {
      return saferEvalNoReturn(expression, this.$data, _objectSpread2(_objectSpread2({}, extraVars()), {}, {$dispatch: this.getDispatchFunction(el)}));
    }

    getDispatchFunction(el) {
      return (event, detail = {}) => {
        el.dispatchEvent(new CustomEvent(event, {detail, bubbles: true}));
      };
    }

    listenForNewElementsToInitialize() {
      const targetNode = this.$el;
      const observerOptions = {childList: true, attributes: true, subtree: true};
      const observer = new MutationObserver(mutations => {
        for (let i = 0; i < mutations.length; i++) {
          const closestParentComponent = mutations[i].target.closest('[x-data]');
          if (!(closestParentComponent && closestParentComponent.isSameNode(this.$el))) continue;
          if (mutations[i].type === 'attributes' && mutations[i].attributeName === 'x-data') {
            const rawData = saferEval(mutations[i].target.getAttribute('x-data') || '{}', {$el: this.$el});
            Object.keys(rawData).forEach(key => {
              if (this.$data[key] !== rawData[key]) {
                this.$data[key] = rawData[key];
              }
            });
          }
          if (mutations[i].addedNodes.length > 0) {
            mutations[i].addedNodes.forEach(node => {
              if (node.nodeType !== 1 || node.__x_inserted_me) return;
              if (node.matches('[x-data]') && !node.__x) {
                node.__x = new Component(node);
                return;
              }
              this.initializeElements(node);
            });
          }
        }
      });
      observer.observe(targetNode, observerOptions);
    }

    getRefsProxy() {
      var self = this;
      var refObj = {};
      return new Proxy(refObj, {
        get(object, property) {
          if (property === '$isAlpineProxy') return true;
          var ref;
          self.walkAndSkipNestedComponents(self.$el, el => {
            if (el.hasAttribute('x-ref') && el.getAttribute('x-ref') === property) {
              ref = el;
            }
          });
          return ref;
        }
      });
    }
  }

  const Alpine = {
    version: "2.5.0",
    pauseMutationObserver: false,
    magicProperties: {},
    onComponentInitializeds: [],
    start: async function start() {
      if (!isTesting()) {
        await domReady();
      }
      this.discoverComponents(el => {
        this.initializeComponent(el);
      });
      document.addEventListener("turbolinks:load", () => {
        this.discoverUninitializedComponents(el => {
          this.initializeComponent(el);
        });
      });
      this.listenForNewUninitializedComponentsAtRunTime(el => {
        this.initializeComponent(el);
      });
    },
    discoverComponents: function discoverComponents(callback) {
      const rootEls = document.querySelectorAll('[x-data]');
      rootEls.forEach(rootEl => {
        callback(rootEl);
      });
    },
    discoverUninitializedComponents: function discoverUninitializedComponents(callback, el = null) {
      const rootEls = (el || document).querySelectorAll('[x-data]');
      Array.from(rootEls).filter(el => el.__x === undefined).forEach(rootEl => {
        callback(rootEl);
      });
    },
    listenForNewUninitializedComponentsAtRunTime: function listenForNewUninitializedComponentsAtRunTime(callback) {
      const targetNode = document.querySelector('body');
      const observerOptions = {childList: true, attributes: true, subtree: true};
      const observer = new MutationObserver(mutations => {
        if (this.pauseMutationObserver) return;
        for (let i = 0; i < mutations.length; i++) {
          if (mutations[i].addedNodes.length > 0) {
            mutations[i].addedNodes.forEach(node => {
              if (node.nodeType !== 1) return;
              if (node.parentElement && node.parentElement.closest('[x-data]')) return;
              this.discoverUninitializedComponents(el => {
                this.initializeComponent(el);
              }, node.parentElement);
            });
          }
        }
      });
      observer.observe(targetNode, observerOptions);
    },
    initializeComponent: function initializeComponent(el) {
      if (!el.__x) {
        try {
          el.__x = new Component(el);
        } catch (error) {
          setTimeout(() => {
            throw error;
          }, 0);
        }
      }
    },
    clone: function clone(component, newEl) {
      if (!newEl.__x) {
        newEl.__x = new Component(newEl, component);
      }
    },
    addMagicProperty: function addMagicProperty(name, callback) {
      this.magicProperties[name] = callback;
    },
    onComponentInitialized: function onComponentInitialized(callback) {
      this.onComponentInitializeds.push(callback);
    }
  };
  if (!isTesting()) {
    window.Alpine = Alpine;
    if (window.deferLoadingAlpine) {
      window.deferLoadingAlpine(function () {
        window.Alpine.start();
      });
    } else {
      window.Alpine.start();
    }
  }
  return Alpine;
})));
!function (n, e) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : n.anime = e()
}(this, function () {
  "use strict";
  var n = {
      update: null,
      begin: null,
      loopBegin: null,
      changeBegin: null,
      change: null,
      changeComplete: null,
      loopComplete: null,
      complete: null,
      loop: 1,
      direction: "normal",
      autoplay: !0,
      timelineOffset: 0
    }, e = {duration: 1e3, delay: 0, endDelay: 0, easing: "easeOutElastic(1, .5)", round: 0},
    r = ["translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "scaleZ", "skew", "skewX", "skewY", "perspective", "matrix", "matrix3d"],
    t = {CSS: {}, springs: {}};

  function a(n, e, r) {
    return Math.min(Math.max(n, e), r)
  }

  function o(n, e) {
    return n.indexOf(e) > -1
  }

  function u(n, e) {
    return n.apply(null, e)
  }

  var i = {
    arr: function (n) {
      return Array.isArray(n)
    }, obj: function (n) {
      return o(Object.prototype.toString.call(n), "Object")
    }, pth: function (n) {
      return i.obj(n) && n.hasOwnProperty("totalLength")
    }, svg: function (n) {
      return n instanceof SVGElement
    }, inp: function (n) {
      return n instanceof HTMLInputElement
    }, dom: function (n) {
      return n.nodeType || i.svg(n)
    }, str: function (n) {
      return "string" == typeof n
    }, fnc: function (n) {
      return "function" == typeof n
    }, und: function (n) {
      return void 0 === n
    }, hex: function (n) {
      return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(n)
    }, rgb: function (n) {
      return /^rgb/.test(n)
    }, hsl: function (n) {
      return /^hsl/.test(n)
    }, col: function (n) {
      return i.hex(n) || i.rgb(n) || i.hsl(n)
    }, key: function (r) {
      return !n.hasOwnProperty(r) && !e.hasOwnProperty(r) && "targets" !== r && "keyframes" !== r
    }
  };

  function c(n) {
    var e = /\(([^)]+)\)/.exec(n);
    return e ? e[1].split(",").map(function (n) {
      return parseFloat(n)
    }) : []
  }

  function s(n, e) {
    var r = c(n), o = a(i.und(r[0]) ? 1 : r[0], .1, 100), u = a(i.und(r[1]) ? 100 : r[1], .1, 100),
      s = a(i.und(r[2]) ? 10 : r[2], .1, 100), f = a(i.und(r[3]) ? 0 : r[3], .1, 100), l = Math.sqrt(u / o),
      d = s / (2 * Math.sqrt(u * o)), p = d < 1 ? l * Math.sqrt(1 - d * d) : 0, h = 1,
      v = d < 1 ? (d * l - f) / p : -f + l;

    function g(n) {
      var r = e ? e * n / 1e3 : n;
      return r = d < 1 ? Math.exp(-r * d * l) * (h * Math.cos(p * r) + v * Math.sin(p * r)) : (h + v * r) * Math.exp(-r * l), 0 === n || 1 === n ? n : 1 - r
    }

    return e ? g : function () {
      var e = t.springs[n];
      if (e) return e;
      for (var r = 0, a = 0; ;) if (1 === g(r += 1 / 6)) {
        if (++a >= 16) break
      } else a = 0;
      var o = r * (1 / 6) * 1e3;
      return t.springs[n] = o, o
    }
  }

  function f(n) {
    return void 0 === n && (n = 10), function (e) {
      return Math.ceil(a(e, 1e-6, 1) * n) * (1 / n)
    }
  }

  var l, d, p = function () {
    var n = 11, e = 1 / (n - 1);

    function r(n, e) {
      return 1 - 3 * e + 3 * n
    }

    function t(n, e) {
      return 3 * e - 6 * n
    }

    function a(n) {
      return 3 * n
    }

    function o(n, e, o) {
      return ((r(e, o) * n + t(e, o)) * n + a(e)) * n
    }

    function u(n, e, o) {
      return 3 * r(e, o) * n * n + 2 * t(e, o) * n + a(e)
    }

    return function (r, t, a, i) {
      if (0 <= r && r <= 1 && 0 <= a && a <= 1) {
        var c = new Float32Array(n);
        if (r !== t || a !== i) for (var s = 0; s < n; ++s) c[s] = o(s * e, r, a);
        return function (n) {
          return r === t && a === i ? n : 0 === n || 1 === n ? n : o(f(n), t, i)
        }
      }

      function f(t) {
        for (var i = 0, s = 1, f = n - 1; s !== f && c[s] <= t; ++s) i += e;
        var l = i + (t - c[--s]) / (c[s + 1] - c[s]) * e, d = u(l, r, a);
        return d >= .001 ? function (n, e, r, t) {
          for (var a = 0; a < 4; ++a) {
            var i = u(e, r, t);
            if (0 === i) return e;
            e -= (o(e, r, t) - n) / i
          }
          return e
        }(t, l, r, a) : 0 === d ? l : function (n, e, r, t, a) {
          for (var u, i, c = 0; (u = o(i = e + (r - e) / 2, t, a) - n) > 0 ? r = i : e = i, Math.abs(u) > 1e-7 && ++c < 10;) ;
          return i
        }(t, i, i + e, r, a)
      }
    }
  }(), h = (l = {
    linear: function () {
      return function (n) {
        return n
      }
    }
  }, d = {
    Sine: function () {
      return function (n) {
        return 1 - Math.cos(n * Math.PI / 2)
      }
    }, Circ: function () {
      return function (n) {
        return 1 - Math.sqrt(1 - n * n)
      }
    }, Back: function () {
      return function (n) {
        return n * n * (3 * n - 2)
      }
    }, Bounce: function () {
      return function (n) {
        for (var e, r = 4; n < ((e = Math.pow(2, --r)) - 1) / 11;) ;
        return 1 / Math.pow(4, 3 - r) - 7.5625 * Math.pow((3 * e - 2) / 22 - n, 2)
      }
    }, Elastic: function (n, e) {
      void 0 === n && (n = 1), void 0 === e && (e = .5);
      var r = a(n, 1, 10), t = a(e, .1, 2);
      return function (n) {
        return 0 === n || 1 === n ? n : -r * Math.pow(2, 10 * (n - 1)) * Math.sin((n - 1 - t / (2 * Math.PI) * Math.asin(1 / r)) * (2 * Math.PI) / t)
      }
    }
  }, ["Quad", "Cubic", "Quart", "Quint", "Expo"].forEach(function (n, e) {
    d[n] = function () {
      return function (n) {
        return Math.pow(n, e + 2)
      }
    }
  }), Object.keys(d).forEach(function (n) {
    var e = d[n];
    l["easeIn" + n] = e, l["easeOut" + n] = function (n, r) {
      return function (t) {
        return 1 - e(n, r)(1 - t)
      }
    }, l["easeInOut" + n] = function (n, r) {
      return function (t) {
        return t < .5 ? e(n, r)(2 * t) / 2 : 1 - e(n, r)(-2 * t + 2) / 2
      }
    }
  }), l);

  function v(n, e) {
    if (i.fnc(n)) return n;
    var r = n.split("(")[0], t = h[r], a = c(n);
    switch (r) {
      case"spring":
        return s(n, e);
      case"cubicBezier":
        return u(p, a);
      case"steps":
        return u(f, a);
      default:
        return u(t, a)
    }
  }

  function g(n) {
    try {
      return document.querySelectorAll(n)
    } catch (n) {
      return
    }
  }

  function m(n, e) {
    for (var r = n.length, t = arguments.length >= 2 ? arguments[1] : void 0, a = [], o = 0; o < r; o++) if (o in n) {
      var u = n[o];
      e.call(t, u, o, n) && a.push(u)
    }
    return a
  }

  function y(n) {
    return n.reduce(function (n, e) {
      return n.concat(i.arr(e) ? y(e) : e)
    }, [])
  }

  function b(n) {
    return i.arr(n) ? n : (i.str(n) && (n = g(n) || n), n instanceof NodeList || n instanceof HTMLCollection ? [].slice.call(n) : [n])
  }

  function x(n, e) {
    return n.some(function (n) {
      return n === e
    })
  }

  function M(n) {
    var e = {};
    for (var r in n) e[r] = n[r];
    return e
  }

  function w(n, e) {
    var r = M(n);
    for (var t in n) r[t] = e.hasOwnProperty(t) ? e[t] : n[t];
    return r
  }

  function k(n, e) {
    var r = M(n);
    for (var t in e) r[t] = i.und(n[t]) ? e[t] : n[t];
    return r
  }

  function O(n) {
    return i.rgb(n) ? (r = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(e = n)) ? "rgba(" + r[1] + ",1)" : e : i.hex(n) ? (t = n.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function (n, e, r, t) {
      return e + e + r + r + t + t
    }), a = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t), "rgba(" + parseInt(a[1], 16) + "," + parseInt(a[2], 16) + "," + parseInt(a[3], 16) + ",1)") : i.hsl(n) ? function (n) {
      var e, r, t,
        a = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(n) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(n),
        o = parseInt(a[1], 10) / 360, u = parseInt(a[2], 10) / 100, i = parseInt(a[3], 10) / 100, c = a[4] || 1;

      function s(n, e, r) {
        return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? n + 6 * (e - n) * r : r < .5 ? e : r < 2 / 3 ? n + (e - n) * (2 / 3 - r) * 6 : n
      }

      if (0 == u) e = r = t = i; else {
        var f = i < .5 ? i * (1 + u) : i + u - i * u, l = 2 * i - f;
        e = s(l, f, o + 1 / 3), r = s(l, f, o), t = s(l, f, o - 1 / 3)
      }
      return "rgba(" + 255 * e + "," + 255 * r + "," + 255 * t + "," + c + ")"
    }(n) : void 0;
    var e, r, t, a
  }

  function C(n) {
    var e = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(n);
    if (e) return e[1]
  }

  function B(n, e) {
    return i.fnc(n) ? n(e.target, e.id, e.total) : n
  }

  function P(n, e) {
    return n.getAttribute(e)
  }

  function I(n, e, r) {
    if (x([r, "deg", "rad", "turn"], C(e))) return e;
    var a = t.CSS[e + r];
    if (!i.und(a)) return a;
    var o = document.createElement(n.tagName),
      u = n.parentNode && n.parentNode !== document ? n.parentNode : document.body;
    u.appendChild(o), o.style.position = "absolute", o.style.width = 100 + r;
    var c = 100 / o.offsetWidth;
    u.removeChild(o);
    var s = c * parseFloat(e);
    return t.CSS[e + r] = s, s
  }

  function T(n, e, r) {
    if (e in n.style) {
      var t = e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
        a = n.style[e] || getComputedStyle(n).getPropertyValue(t) || "0";
      return r ? I(n, a, r) : a
    }
  }

  function D(n, e) {
    return i.dom(n) && !i.inp(n) && (P(n, e) || i.svg(n) && n[e]) ? "attribute" : i.dom(n) && x(r, e) ? "transform" : i.dom(n) && "transform" !== e && T(n, e) ? "css" : null != n[e] ? "object" : void 0
  }

  function E(n) {
    if (i.dom(n)) {
      for (var e, r = n.style.transform || "", t = /(\w+)\(([^)]*)\)/g, a = new Map; e = t.exec(r);) a.set(e[1], e[2]);
      return a
    }
  }

  function F(n, e, r, t) {
    var a,
      u = o(e, "scale") ? 1 : 0 + (o(a = e, "translate") || "perspective" === a ? "px" : o(a, "rotate") || o(a, "skew") ? "deg" : void 0),
      i = E(n).get(e) || u;
    return r && (r.transforms.list.set(e, i), r.transforms.last = e), t ? I(n, i, t) : i
  }

  function N(n, e, r, t) {
    switch (D(n, e)) {
      case"transform":
        return F(n, e, t, r);
      case"css":
        return T(n, e, r);
      case"attribute":
        return P(n, e);
      default:
        return n[e] || 0
    }
  }

  function A(n, e) {
    var r = /^(\*=|\+=|-=)/.exec(n);
    if (!r) return n;
    var t = C(n) || 0, a = parseFloat(e), o = parseFloat(n.replace(r[0], ""));
    switch (r[0][0]) {
      case"+":
        return a + o + t;
      case"-":
        return a - o + t;
      case"*":
        return a * o + t
    }
  }

  function L(n, e) {
    if (i.col(n)) return O(n);
    if (/\s/g.test(n)) return n;
    var r = C(n), t = r ? n.substr(0, n.length - r.length) : n;
    return e ? t + e : t
  }

  function j(n, e) {
    return Math.sqrt(Math.pow(e.x - n.x, 2) + Math.pow(e.y - n.y, 2))
  }

  function S(n) {
    for (var e, r = n.points, t = 0, a = 0; a < r.numberOfItems; a++) {
      var o = r.getItem(a);
      a > 0 && (t += j(e, o)), e = o
    }
    return t
  }

  function q(n) {
    if (n.getTotalLength) return n.getTotalLength();
    switch (n.tagName.toLowerCase()) {
      case"circle":
        return o = n, 2 * Math.PI * P(o, "r");
      case"rect":
        return 2 * P(a = n, "width") + 2 * P(a, "height");
      case"line":
        return j({x: P(t = n, "x1"), y: P(t, "y1")}, {x: P(t, "x2"), y: P(t, "y2")});
      case"polyline":
        return S(n);
      case"polygon":
        return r = (e = n).points, S(e) + j(r.getItem(r.numberOfItems - 1), r.getItem(0))
    }
    var e, r, t, a, o
  }

  function $(n, e) {
    var r = e || {}, t = r.el || function (n) {
        for (var e = n.parentNode; i.svg(e) && i.svg(e.parentNode);) e = e.parentNode;
        return e
      }(n), a = t.getBoundingClientRect(), o = P(t, "viewBox"), u = a.width, c = a.height,
      s = r.viewBox || (o ? o.split(" ") : [0, 0, u, c]);
    return {el: t, viewBox: s, x: s[0] / 1, y: s[1] / 1, w: u / s[2], h: c / s[3]}
  }

  function X(n, e) {
    function r(r) {
      void 0 === r && (r = 0);
      var t = e + r >= 1 ? e + r : 0;
      return n.el.getPointAtLength(t)
    }

    var t = $(n.el, n.svg), a = r(), o = r(-1), u = r(1);
    switch (n.property) {
      case"x":
        return (a.x - t.x) * t.w;
      case"y":
        return (a.y - t.y) * t.h;
      case"angle":
        return 180 * Math.atan2(u.y - o.y, u.x - o.x) / Math.PI
    }
  }

  function Y(n, e) {
    var r = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g, t = L(i.pth(n) ? n.totalLength : n, e) + "";
    return {original: t, numbers: t.match(r) ? t.match(r).map(Number) : [0], strings: i.str(n) || e ? t.split(r) : []}
  }

  function Z(n) {
    return m(n ? y(i.arr(n) ? n.map(b) : b(n)) : [], function (n, e, r) {
      return r.indexOf(n) === e
    })
  }

  function Q(n) {
    var e = Z(n);
    return e.map(function (n, r) {
      return {target: n, id: r, total: e.length, transforms: {list: E(n)}}
    })
  }

  function V(n, e) {
    var r = M(e);
    if (/^spring/.test(r.easing) && (r.duration = s(r.easing)), i.arr(n)) {
      var t = n.length;
      2 === t && !i.obj(n[0]) ? n = {value: n} : i.fnc(e.duration) || (r.duration = e.duration / t)
    }
    var a = i.arr(n) ? n : [n];
    return a.map(function (n, r) {
      var t = i.obj(n) && !i.pth(n) ? n : {value: n};
      return i.und(t.delay) && (t.delay = r ? 0 : e.delay), i.und(t.endDelay) && (t.endDelay = r === a.length - 1 ? e.endDelay : 0), t
    }).map(function (n) {
      return k(n, r)
    })
  }

  function z(n, e) {
    var r = [], t = e.keyframes;
    for (var a in t && (e = k(function (n) {
      for (var e = m(y(n.map(function (n) {
        return Object.keys(n)
      })), function (n) {
        return i.key(n)
      }).reduce(function (n, e) {
        return n.indexOf(e) < 0 && n.push(e), n
      }, []), r = {}, t = function (t) {
        var a = e[t];
        r[a] = n.map(function (n) {
          var e = {};
          for (var r in n) i.key(r) ? r == a && (e.value = n[r]) : e[r] = n[r];
          return e
        })
      }, a = 0; a < e.length; a++) t(a);
      return r
    }(t), e)), e) i.key(a) && r.push({name: a, tweens: V(e[a], n)});
    return r
  }

  function H(n, e) {
    var r;
    return n.tweens.map(function (t) {
      var a = function (n, e) {
          var r = {};
          for (var t in n) {
            var a = B(n[t], e);
            i.arr(a) && 1 === (a = a.map(function (n) {
              return B(n, e)
            })).length && (a = a[0]), r[t] = a
          }
          return r.duration = parseFloat(r.duration), r.delay = parseFloat(r.delay), r
        }(t, e), o = a.value, u = i.arr(o) ? o[1] : o, c = C(u), s = N(e.target, n.name, c, e), f = r ? r.to.original : s,
        l = i.arr(o) ? o[0] : f, d = C(l) || C(s), p = c || d;
      return i.und(u) && (u = f), a.from = Y(l, p), a.to = Y(A(u, l), p), a.start = r ? r.end : 0, a.end = a.start + a.delay + a.duration + a.endDelay, a.easing = v(a.easing, a.duration), a.isPath = i.pth(o), a.isColor = i.col(a.from.original), a.isColor && (a.round = 1), r = a, a
    })
  }

  var G = {
    css: function (n, e, r) {
      return n.style[e] = r
    }, attribute: function (n, e, r) {
      return n.setAttribute(e, r)
    }, object: function (n, e, r) {
      return n[e] = r
    }, transform: function (n, e, r, t, a) {
      if (t.list.set(e, r), e === t.last || a) {
        var o = "";
        t.list.forEach(function (n, e) {
          o += e + "(" + n + ") "
        }), n.style.transform = o
      }
    }
  };

  function R(n, e) {
    Q(n).forEach(function (n) {
      for (var r in e) {
        var t = B(e[r], n), a = n.target, o = C(t), u = N(a, r, o, n), i = A(L(t, o || C(u)), u), c = D(a, r);
        G[c](a, r, i, n.transforms, !0)
      }
    })
  }

  function W(n, e) {
    return m(y(n.map(function (n) {
      return e.map(function (e) {
        return function (n, e) {
          var r = D(n.target, e.name);
          if (r) {
            var t = H(e, n), a = t[t.length - 1];
            return {
              type: r,
              property: e.name,
              animatable: n,
              tweens: t,
              duration: a.end,
              delay: t[0].delay,
              endDelay: a.endDelay
            }
          }
        }(n, e)
      })
    })), function (n) {
      return !i.und(n)
    })
  }

  function J(n, e) {
    var r = n.length, t = function (n) {
      return n.timelineOffset ? n.timelineOffset : 0
    }, a = {};
    return a.duration = r ? Math.max.apply(Math, n.map(function (n) {
      return t(n) + n.duration
    })) : e.duration, a.delay = r ? Math.min.apply(Math, n.map(function (n) {
      return t(n) + n.delay
    })) : e.delay, a.endDelay = r ? a.duration - Math.max.apply(Math, n.map(function (n) {
      return t(n) + n.duration - n.endDelay
    })) : e.endDelay, a
  }

  var K = 0;
  var U, _ = [], nn = [], en = function () {
    function n() {
      U = requestAnimationFrame(e)
    }

    function e(e) {
      var r = _.length;
      if (r) {
        for (var t = 0; t < r;) {
          var a = _[t];
          if (a.paused) {
            var o = _.indexOf(a);
            o > -1 && (_.splice(o, 1), r = _.length)
          } else a.tick(e);
          t++
        }
        n()
      } else U = cancelAnimationFrame(U)
    }

    return n
  }();

  function rn(r) {
    void 0 === r && (r = {});
    var t, o = 0, u = 0, i = 0, c = 0, s = null;

    function f(n) {
      var e = window.Promise && new Promise(function (n) {
        return s = n
      });
      return n.finished = e, e
    }

    var l, d, p, h, v, g, y, b,
      x = (d = w(n, l = r), p = w(e, l), h = z(p, l), v = Q(l.targets), g = W(v, h), y = J(g, p), b = K, K++, k(d, {
        id: b,
        children: [],
        animatables: v,
        animations: g,
        duration: y.duration,
        delay: y.delay,
        endDelay: y.endDelay
      }));
    f(x);

    function M() {
      var n = x.direction;
      "alternate" !== n && (x.direction = "normal" !== n ? "normal" : "reverse"), x.reversed = !x.reversed, t.forEach(function (n) {
        return n.reversed = x.reversed
      })
    }

    function O(n) {
      return x.reversed ? x.duration - n : n
    }

    function C() {
      o = 0, u = O(x.currentTime) * (1 / rn.speed)
    }

    function B(n, e) {
      e && e.seek(n - e.timelineOffset)
    }

    function P(n) {
      for (var e = 0, r = x.animations, t = r.length; e < t;) {
        var o = r[e], u = o.animatable, i = o.tweens, c = i.length - 1, s = i[c];
        c && (s = m(i, function (e) {
          return n < e.end
        })[0] || s);
        for (var f = a(n - s.start - s.delay, 0, s.duration) / s.duration, l = isNaN(f) ? 1 : s.easing(f), d = s.to.strings, p = s.round, h = [], v = s.to.numbers.length, g = void 0, y = 0; y < v; y++) {
          var b = void 0, M = s.to.numbers[y], w = s.from.numbers[y] || 0;
          b = s.isPath ? X(s.value, l * M) : w + l * (M - w), p && (s.isColor && y > 2 || (b = Math.round(b * p) / p)), h.push(b)
        }
        var k = d.length;
        if (k) {
          g = d[0];
          for (var O = 0; O < k; O++) {
            d[O];
            var C = d[O + 1], B = h[O];
            isNaN(B) || (g += C ? B + C : B + " ")
          }
        } else g = h[0];
        G[o.type](u.target, o.property, g, u.transforms), o.currentValue = g, e++
      }
    }

    function I(n) {
      x[n] && !x.passThrough && x[n](x)
    }

    function T(n) {
      var e = x.duration, r = x.delay, l = e - x.endDelay, d = O(n);
      x.progress = a(d / e * 100, 0, 100), x.reversePlayback = d < x.currentTime, t && function (n) {
        if (x.reversePlayback) for (var e = c; e--;) B(n, t[e]); else for (var r = 0; r < c; r++) B(n, t[r])
      }(d), !x.began && x.currentTime > 0 && (x.began = !0, I("begin")), !x.loopBegan && x.currentTime > 0 && (x.loopBegan = !0, I("loopBegin")), d <= r && 0 !== x.currentTime && P(0), (d >= l && x.currentTime !== e || !e) && P(e), d > r && d < l ? (x.changeBegan || (x.changeBegan = !0, x.changeCompleted = !1, I("changeBegin")), I("change"), P(d)) : x.changeBegan && (x.changeCompleted = !0, x.changeBegan = !1, I("changeComplete")), x.currentTime = a(d, 0, e), x.began && I("update"), n >= e && (u = 0, x.remaining && !0 !== x.remaining && x.remaining--, x.remaining ? (o = i, I("loopComplete"), x.loopBegan = !1, "alternate" === x.direction && M()) : (x.paused = !0, x.completed || (x.completed = !0, I("loopComplete"), I("complete"), !x.passThrough && "Promise" in window && (s(), f(x)))))
    }

    return x.reset = function () {
      var n = x.direction;
      x.passThrough = !1, x.currentTime = 0, x.progress = 0, x.paused = !0, x.began = !1, x.loopBegan = !1, x.changeBegan = !1, x.completed = !1, x.changeCompleted = !1, x.reversePlayback = !1, x.reversed = "reverse" === n, x.remaining = x.loop, t = x.children;
      for (var e = c = t.length; e--;) x.children[e].reset();
      (x.reversed && !0 !== x.loop || "alternate" === n && 1 === x.loop) && x.remaining++, P(x.reversed ? x.duration : 0)
    }, x.set = function (n, e) {
      return R(n, e), x
    }, x.tick = function (n) {
      i = n, o || (o = i), T((i + (u - o)) * rn.speed)
    }, x.seek = function (n) {
      T(O(n))
    }, x.pause = function () {
      x.paused = !0, C()
    }, x.play = function () {
      x.paused && (x.completed && x.reset(), x.paused = !1, _.push(x), C(), U || en())
    }, x.reverse = function () {
      M(), x.completed = !x.reversed, C()
    }, x.restart = function () {
      x.reset(), x.play()
    }, x.reset(), x.autoplay && x.play(), x
  }

  function tn(n, e) {
    for (var r = e.length; r--;) x(n, e[r].animatable.target) && e.splice(r, 1)
  }

  return "undefined" != typeof document && document.addEventListener("visibilitychange", function () {
    document.hidden ? (_.forEach(function (n) {
      return n.pause()
    }), nn = _.slice(0), rn.running = _ = []) : nn.forEach(function (n) {
      return n.play()
    })
  }), rn.version = "3.2.0", rn.speed = 1, rn.running = _, rn.remove = function (n) {
    for (var e = Z(n), r = _.length; r--;) {
      var t = _[r], a = t.animations, o = t.children;
      tn(e, a);
      for (var u = o.length; u--;) {
        var i = o[u], c = i.animations;
        tn(e, c), c.length || i.children.length || o.splice(u, 1)
      }
      a.length || o.length || t.pause()
    }
  }, rn.get = N, rn.set = R, rn.convertPx = I, rn.path = function (n, e) {
    var r = i.str(n) ? g(n)[0] : n, t = e || 100;
    return function (n) {
      return {property: n, el: r, svg: $(r), totalLength: q(r) * (t / 100)}
    }
  }, rn.setDashoffset = function (n) {
    var e = q(n);
    return n.setAttribute("stroke-dasharray", e), e
  }, rn.stagger = function (n, e) {
    void 0 === e && (e = {});
    var r = e.direction || "normal", t = e.easing ? v(e.easing) : null, a = e.grid, o = e.axis, u = e.from || 0,
      c = "first" === u, s = "center" === u, f = "last" === u, l = i.arr(n), d = l ? parseFloat(n[0]) : parseFloat(n),
      p = l ? parseFloat(n[1]) : 0, h = C(l ? n[1] : n) || 0, g = e.start || 0 + (l ? d : 0), m = [], y = 0;
    return function (n, e, i) {
      if (c && (u = 0), s && (u = (i - 1) / 2), f && (u = i - 1), !m.length) {
        for (var v = 0; v < i; v++) {
          if (a) {
            var b = s ? (a[0] - 1) / 2 : u % a[0], x = s ? (a[1] - 1) / 2 : Math.floor(u / a[0]), M = b - v % a[0],
              w = x - Math.floor(v / a[0]), k = Math.sqrt(M * M + w * w);
            "x" === o && (k = -M), "y" === o && (k = -w), m.push(k)
          } else m.push(Math.abs(u - v));
          y = Math.max.apply(Math, m)
        }
        t && (m = m.map(function (n) {
          return t(n / y) * y
        })), "reverse" === r && (m = m.map(function (n) {
          return o ? n < 0 ? -1 * n : -n : Math.abs(y - n)
        }))
      }
      return g + (l ? (p - d) / y : d) * (Math.round(100 * m[e]) / 100) + h
    }
  }, rn.timeline = function (n) {
    void 0 === n && (n = {});
    var r = rn(n);
    return r.duration = 0, r.add = function (t, a) {
      var o = _.indexOf(r), u = r.children;

      function c(n) {
        n.passThrough = !0
      }

      o > -1 && _.splice(o, 1);
      for (var s = 0; s < u.length; s++) c(u[s]);
      var f = k(t, w(e, n));
      f.targets = f.targets || n.targets;
      var l = r.duration;
      f.autoplay = !1, f.direction = r.direction, f.timelineOffset = i.und(a) ? l : A(a, l), c(r), r.seek(f.timelineOffset);
      var d = rn(f);
      c(d), u.push(d);
      var p = J(u, n);
      return r.delay = p.delay, r.endDelay = p.endDelay, r.duration = p.duration, r.seek(0), r.reset(), r.autoplay && r.play(), r
    }, r
  }, rn.easing = v, rn.penner = h, rn.random = function (n, e) {
    return Math.floor(Math.random() * (e - n + 1)) + n
  }, rn
});/*!
Waypoints - 4.0.1
Copyright © 2011-2016 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blob/master/licenses.txt
*/
!function () {
  "use strict";

  function t(n) {
    if (!n) throw new Error("No options passed to Waypoint constructor");
    if (!n.element) throw new Error("No element option passed to Waypoint constructor");
    if (!n.handler) throw new Error("No handler option passed to Waypoint constructor");
    this.key = "waypoint-" + e, this.options = t.Adapter.extend({}, t.defaults, n), this.element = this.options.element, this.adapter = new t.Adapter(this.element), this.callback = n.handler, this.axis = this.options.horizontal ? "horizontal" : "vertical", this.enabled = this.options.enabled, this.triggerPoint = null, this.group = t.Group.findOrCreate({
      name: this.options.group,
      axis: this.axis
    }), this.context = t.Context.findOrCreateByElement(this.options.context), t.offsetAliases[this.options.offset] && (this.options.offset = t.offsetAliases[this.options.offset]), this.group.add(this), this.context.add(this), i[this.key] = this, e += 1
  }

  var e = 0, i = {};
  t.prototype.queueTrigger = function (t) {
    this.group.queueTrigger(this, t)
  }, t.prototype.trigger = function (t) {
    this.enabled && this.callback && this.callback.apply(this, t)
  }, t.prototype.destroy = function () {
    this.context.remove(this), this.group.remove(this), delete i[this.key]
  }, t.prototype.disable = function () {
    return this.enabled = !1, this
  }, t.prototype.enable = function () {
    return this.context.refresh(), this.enabled = !0, this
  }, t.prototype.next = function () {
    return this.group.next(this)
  }, t.prototype.previous = function () {
    return this.group.previous(this)
  }, t.invokeAll = function (t) {
    var e = [];
    for (var n in i) e.push(i[n]);
    for (var o = 0, r = e.length; r > o; o++) e[o][t]()
  }, t.destroyAll = function () {
    t.invokeAll("destroy")
  }, t.disableAll = function () {
    t.invokeAll("disable")
  }, t.enableAll = function () {
    t.Context.refreshAll();
    for (var e in i) i[e].enabled = !0;
    return this
  }, t.refreshAll = function () {
    t.Context.refreshAll()
  }, t.viewportHeight = function () {
    return window.innerHeight || document.documentElement.clientHeight
  }, t.viewportWidth = function () {
    return document.documentElement.clientWidth
  }, t.adapters = [], t.defaults = {
    context: window,
    continuous: !0,
    enabled: !0,
    group: "default",
    horizontal: !1,
    offset: 0
  }, t.offsetAliases = {
    "bottom-in-view": function () {
      return this.context.innerHeight() - this.adapter.outerHeight()
    }, "right-in-view": function () {
      return this.context.innerWidth() - this.adapter.outerWidth()
    }
  }, window.Waypoint = t
}(), function () {
  "use strict";

  function t(t) {
    window.setTimeout(t, 1e3 / 60)
  }

  function e(t) {
    this.element = t, this.Adapter = o.Adapter, this.adapter = new this.Adapter(t), this.key = "waypoint-context-" + i, this.didScroll = !1, this.didResize = !1, this.oldScroll = {
      x: this.adapter.scrollLeft(),
      y: this.adapter.scrollTop()
    }, this.waypoints = {
      vertical: {},
      horizontal: {}
    }, t.waypointContextKey = this.key, n[t.waypointContextKey] = this, i += 1, o.windowContext || (o.windowContext = !0, o.windowContext = new e(window)), this.createThrottledScrollHandler(), this.createThrottledResizeHandler()
  }

  var i = 0, n = {}, o = window.Waypoint, r = window.onload;
  e.prototype.add = function (t) {
    var e = t.options.horizontal ? "horizontal" : "vertical";
    this.waypoints[e][t.key] = t, this.refresh()
  }, e.prototype.checkEmpty = function () {
    var t = this.Adapter.isEmptyObject(this.waypoints.horizontal),
      e = this.Adapter.isEmptyObject(this.waypoints.vertical), i = this.element == this.element.window;
    t && e && !i && (this.adapter.off(".waypoints"), delete n[this.key])
  }, e.prototype.createThrottledResizeHandler = function () {
    function t() {
      e.handleResize(), e.didResize = !1
    }

    var e = this;
    this.adapter.on("resize.waypoints", function () {
      e.didResize || (e.didResize = !0, o.requestAnimationFrame(t))
    })
  }, e.prototype.createThrottledScrollHandler = function () {
    function t() {
      e.handleScroll(), e.didScroll = !1
    }

    var e = this;
    this.adapter.on("scroll.waypoints", function () {
      (!e.didScroll || o.isTouch) && (e.didScroll = !0, o.requestAnimationFrame(t))
    })
  }, e.prototype.handleResize = function () {
    o.Context.refreshAll()
  }, e.prototype.handleScroll = function () {
    var t = {}, e = {
      horizontal: {
        newScroll: this.adapter.scrollLeft(),
        oldScroll: this.oldScroll.x,
        forward: "right",
        backward: "left"
      }, vertical: {newScroll: this.adapter.scrollTop(), oldScroll: this.oldScroll.y, forward: "down", backward: "up"}
    };
    for (var i in e) {
      var n = e[i], o = n.newScroll > n.oldScroll, r = o ? n.forward : n.backward;
      for (var s in this.waypoints[i]) {
        var l = this.waypoints[i][s];
        if (null !== l.triggerPoint) {
          var a = n.oldScroll < l.triggerPoint, h = n.newScroll >= l.triggerPoint, p = a && h, u = !a && !h;
          (p || u) && (l.queueTrigger(r), t[l.group.id] = l.group)
        }
      }
    }
    for (var d in t) t[d].flushTriggers();
    this.oldScroll = {x: e.horizontal.newScroll, y: e.vertical.newScroll}
  }, e.prototype.innerHeight = function () {
    return this.element == this.element.window ? o.viewportHeight() : this.adapter.innerHeight()
  }, e.prototype.remove = function (t) {
    delete this.waypoints[t.axis][t.key], this.checkEmpty()
  }, e.prototype.innerWidth = function () {
    return this.element == this.element.window ? o.viewportWidth() : this.adapter.innerWidth()
  }, e.prototype.destroy = function () {
    var t = [];
    for (var e in this.waypoints) for (var i in this.waypoints[e]) t.push(this.waypoints[e][i]);
    for (var n = 0, o = t.length; o > n; n++) t[n].destroy()
  }, e.prototype.refresh = function () {
    var t, e = this.element == this.element.window, i = e ? void 0 : this.adapter.offset(), n = {};
    this.handleScroll(), t = {
      horizontal: {
        contextOffset: e ? 0 : i.left,
        contextScroll: e ? 0 : this.oldScroll.x,
        contextDimension: this.innerWidth(),
        oldScroll: this.oldScroll.x,
        forward: "right",
        backward: "left",
        offsetProp: "left"
      },
      vertical: {
        contextOffset: e ? 0 : i.top,
        contextScroll: e ? 0 : this.oldScroll.y,
        contextDimension: this.innerHeight(),
        oldScroll: this.oldScroll.y,
        forward: "down",
        backward: "up",
        offsetProp: "top"
      }
    };
    for (var r in t) {
      var s = t[r];
      for (var l in this.waypoints[r]) {
        var a, h, p, u, d, f = this.waypoints[r][l], c = f.options.offset, w = f.triggerPoint, y = 0, g = null == w;
        f.element !== f.element.window && (y = f.adapter.offset()[s.offsetProp]), "function" == typeof c ? c = c.apply(f) : "string" == typeof c && (c = parseFloat(c), f.options.offset.indexOf("%") > -1 && (c = Math.ceil(s.contextDimension * c / 100))), a = s.contextScroll - s.contextOffset, f.triggerPoint = Math.floor(y + a - c), h = w < s.oldScroll, p = f.triggerPoint >= s.oldScroll, u = h && p, d = !h && !p, !g && u ? (f.queueTrigger(s.backward), n[f.group.id] = f.group) : !g && d ? (f.queueTrigger(s.forward), n[f.group.id] = f.group) : g && s.oldScroll >= f.triggerPoint && (f.queueTrigger(s.forward), n[f.group.id] = f.group)
      }
    }
    return o.requestAnimationFrame(function () {
      for (var t in n) n[t].flushTriggers()
    }), this
  }, e.findOrCreateByElement = function (t) {
    return e.findByElement(t) || new e(t)
  }, e.refreshAll = function () {
    for (var t in n) n[t].refresh()
  }, e.findByElement = function (t) {
    return n[t.waypointContextKey]
  }, window.onload = function () {
    r && r(), e.refreshAll()
  }, o.requestAnimationFrame = function (e) {
    var i = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || t;
    i.call(window, e)
  }, o.Context = e
}(), function () {
  "use strict";

  function t(t, e) {
    return t.triggerPoint - e.triggerPoint
  }

  function e(t, e) {
    return e.triggerPoint - t.triggerPoint
  }

  function i(t) {
    this.name = t.name, this.axis = t.axis, this.id = this.name + "-" + this.axis, this.waypoints = [], this.clearTriggerQueues(), n[this.axis][this.name] = this
  }

  var n = {vertical: {}, horizontal: {}}, o = window.Waypoint;
  i.prototype.add = function (t) {
    this.waypoints.push(t)
  }, i.prototype.clearTriggerQueues = function () {
    this.triggerQueues = {up: [], down: [], left: [], right: []}
  }, i.prototype.flushTriggers = function () {
    for (var i in this.triggerQueues) {
      var n = this.triggerQueues[i], o = "up" === i || "left" === i;
      n.sort(o ? e : t);
      for (var r = 0, s = n.length; s > r; r += 1) {
        var l = n[r];
        (l.options.continuous || r === n.length - 1) && l.trigger([i])
      }
    }
    this.clearTriggerQueues()
  }, i.prototype.next = function (e) {
    this.waypoints.sort(t);
    var i = o.Adapter.inArray(e, this.waypoints), n = i === this.waypoints.length - 1;
    return n ? null : this.waypoints[i + 1]
  }, i.prototype.previous = function (e) {
    this.waypoints.sort(t);
    var i = o.Adapter.inArray(e, this.waypoints);
    return i ? this.waypoints[i - 1] : null
  }, i.prototype.queueTrigger = function (t, e) {
    this.triggerQueues[e].push(t)
  }, i.prototype.remove = function (t) {
    var e = o.Adapter.inArray(t, this.waypoints);
    e > -1 && this.waypoints.splice(e, 1)
  }, i.prototype.first = function () {
    return this.waypoints[0]
  }, i.prototype.last = function () {
    return this.waypoints[this.waypoints.length - 1]
  }, i.findOrCreate = function (t) {
    return n[t.axis][t.name] || new i(t)
  }, o.Group = i
}(), function () {
  "use strict";

  function t(t) {
    return t === t.window
  }

  function e(e) {
    return t(e) ? e : e.defaultView
  }

  function i(t) {
    this.element = t, this.handlers = {}
  }

  var n = window.Waypoint;
  i.prototype.innerHeight = function () {
    var e = t(this.element);
    return e ? this.element.innerHeight : this.element.clientHeight
  }, i.prototype.innerWidth = function () {
    var e = t(this.element);
    return e ? this.element.innerWidth : this.element.clientWidth
  }, i.prototype.off = function (t, e) {
    function i(t, e, i) {
      for (var n = 0, o = e.length - 1; o > n; n++) {
        var r = e[n];
        i && i !== r || t.removeEventListener(r)
      }
    }

    var n = t.split("."), o = n[0], r = n[1], s = this.element;
    if (r && this.handlers[r] && o) i(s, this.handlers[r][o], e), this.handlers[r][o] = []; else if (o) for (var l in this.handlers) i(s, this.handlers[l][o] || [], e), this.handlers[l][o] = []; else if (r && this.handlers[r]) {
      for (var a in this.handlers[r]) i(s, this.handlers[r][a], e);
      this.handlers[r] = {}
    }
  }, i.prototype.offset = function () {
    if (!this.element.ownerDocument) return null;
    var t = this.element.ownerDocument.documentElement, i = e(this.element.ownerDocument), n = {top: 0, left: 0};
    return this.element.getBoundingClientRect && (n = this.element.getBoundingClientRect()), {
      top: n.top + i.pageYOffset - t.clientTop,
      left: n.left + i.pageXOffset - t.clientLeft
    }
  }, i.prototype.on = function (t, e) {
    var i = t.split("."), n = i[0], o = i[1] || "__default", r = this.handlers[o] = this.handlers[o] || {},
      s = r[n] = r[n] || [];
    s.push(e), this.element.addEventListener(n, e)
  }, i.prototype.outerHeight = function (e) {
    var i, n = this.innerHeight();
    return e && !t(this.element) && (i = window.getComputedStyle(this.element), n += parseInt(i.marginTop, 10), n += parseInt(i.marginBottom, 10)), n
  }, i.prototype.outerWidth = function (e) {
    var i, n = this.innerWidth();
    return e && !t(this.element) && (i = window.getComputedStyle(this.element), n += parseInt(i.marginLeft, 10), n += parseInt(i.marginRight, 10)), n
  }, i.prototype.scrollLeft = function () {
    var t = e(this.element);
    return t ? t.pageXOffset : this.element.scrollLeft
  }, i.prototype.scrollTop = function () {
    var t = e(this.element);
    return t ? t.pageYOffset : this.element.scrollTop
  }, i.extend = function () {
    function t(t, e) {
      if ("object" == typeof t && "object" == typeof e) for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
      return t
    }

    for (var e = Array.prototype.slice.call(arguments), i = 1, n = e.length; n > i; i++) t(e[0], e[i]);
    return e[0]
  }, i.inArray = function (t, e, i) {
    return null == e ? -1 : e.indexOf(t, i)
  }, i.isEmptyObject = function (t) {
    for (var e in t) return !1;
    return !0
  }, n.adapters.push({name: "noframework", Adapter: i}), n.Adapter = i
}();

function getYear() {
  let d = new Date();
  d = d.getFullYear();
  return d;
}

const queryString = window.location.search;
const urlParams = new URLSearchParams(queryString);

function galaxyChoose() {
  return {
    txid: urlParams.get('txid'),
    affid: urlParams.get('affid'),
    clickid: urlParams.get('clickid'),
    source: urlParams.get('source'),
    fbpixelid: urlParams.get('fbpixelid'),
    fbevent: urlParams.get('fbevent'),
    footerYear: getYear(),
    selectedGold: false,
    selectedSpaceGray: false,
    selectedSilver: false,
    selectedMidnightGreen: false,
    introAnimationDone: false,
    scrolledWindow: false,
    introAnimation(phone1, phone2, phone3, phone4) {
      anime({
        targets: ('.app--scroller-animation svg .scroll-down'),
        opacity: [0, 1],
        translateY: [-10, 0],
        delay: anime.stagger(250, {easing: 'linear'}),
        duration: 1250,
        loop: true,
        easing: 'linear'
      });
      anime({targets: phone4, opacity: 1, delay: 0, duration: 150, translateX: '0%', easing: 'linear'});
      anime({
        targets: [phone1, phone2, phone3], opacity: 1, rotate: function (el, i, l) {
          return (i + 1) * -5;
        }, delay: function (el, i, l) {
          return (i + 1) * 250;
        }, translateX: function (el, i, l) {
          return ((i + 1) * 15 * -1) + '%'
        }, duration: 400, complete: () => {
          this.introAnimationDone = true;
        }
      });
    },
    checkStock(spinner, text) {
      setTimeout(function () {
        spinner.setAttribute("style", "opacity: 0;");
      }, 2500)
      setTimeout(function () {
        spinner.setAttribute("style", "opacity: 0; display: none;");
        text.setAttribute("style", "opacity: 1;");
        text.children[0].children[0].children[1].setAttribute("style", "stroke-dashoffset: 0px;");
      }, 2750)
      setTimeout(function () {
        text.children[0].children[0].children[1].setAttribute("style", "stroke-dashoffset: 0px;");
      }, 3250)
    },
    colorSelected: false,
    chooseColor(event, buttonsParent, phoneWhite, phoneSpaceGray, phoneBlue, phonePink) {
      let clickedColor = event.target;
      if (clickedColor.tagName == 'A' && this.introAnimationDone) {
        window.scroll({top: 0, left: 0, behavior: 'smooth'});
        let allPhones = [phonePink, phoneWhite, phoneSpaceGray, phoneBlue];
        let selectedColor;
        if (clickedColor.getAttribute('href') == '#cloudwhite') {
          selectedColor = phoneWhite;
        } else if (clickedColor.getAttribute('href') == '#cloudblue') {
          selectedColor = phoneBlue;
        } else if (clickedColor.getAttribute('href') == '#pink') {
          selectedColor = phonePink;
        } else if (clickedColor.getAttribute('href') == '#spacegray') {
          selectedColor = phoneSpaceGray;
        }

        function animateChosenPhone(phone) {
          let timeline = anime.timeline({easing: 'easeInOutQuad', duration: 500});
          if (phone != 'none') {
            timeline.add({
              targets: allPhones, opacity: 1, rotate: function (el, i, l) {
                return i * -5;
              }, delay: 0, translateY: +20, translateX: function (el, i, l) {
                return (i * 15 * -1) + '%'
              }, scale: 1, duration: 500
            }).add({
              targets: phone,
              opacity: 1,
              rotate: -10,
              delay: 0,
              translateY: -40,
              translateX: function (el, i, l) {
                if (el == phoneBlue) {
                  return -90
                } else if (el == phoneSpaceGray) {
                  return -75
                } else {
                  return -50
                }
              },
              duration: 501,
              scale: 1
            }, '-=400')
          } else {
            timeline.add({
              targets: allPhones, opacity: 1, rotate: function (el, i, l) {
                return i * -5;
              }, delay: 0, translateY: 0, translateX: function (el, i, l) {
                return (i * 15 * -1) + '%'
              }, scale: 1, duration: 500
            })
          }
        }

        if (!clickedColor.classList.contains('phone--form-color-selected') && !this.colorSelected) {
          this.colorSelected = true;
          clickedColor.classList.add('phone--form-color-selected');
          animateChosenPhone(selectedColor);
        } else if (clickedColor.classList.contains('phone--form-color-selected') && this.colorSelected) {
          this.colorSelected = false;
          clickedColor.classList.remove('phone--form-color-selected');
          animateChosenPhone('none');
        } else if (!clickedColor.classList.contains('phone--form-color-selected') && this.colorSelected) {
          let i;
          for (i = 0; i < buttonsParent.children.length; i++) {
            buttonsParent.children[i].children[0].classList.remove('phone--form-color-selected');
          }
          clickedColor.classList.add('phone--form-color-selected');
          animateChosenPhone(selectedColor);
        }
      }
    }
  }
}

function slideIn(amount, targets, waypointTrigger) {
  anime({targets: targets, delay: 0, duration: 250, translateX: amount, opacity: 1, easing: 'easeInOutQuad',});
  waypointTrigger.destroy();
}

anime.set('.phone--feature-camera-app, .phone--feature-a13-bionic-chip, .phone--feature-video-app + .phone--feature-description', {
  translateX: '-=150',
  opacity: 0
});
anime.set('.phone--feature-video-app, .phone--feature-camera-app + .phone--feature-description, .phone--feature-a13-bionic-chip + .phone--feature-description', {
  translateX: '+=150',
  opacity: 0
});
let phone1slideIn = new Waypoint({
  element: document.querySelector('.phone--feature-camera-app'), handler: function () {
    slideIn('+=150', this.element, this);
  }, offset: '75%'
});
let phone1DescSlideIn = new Waypoint({
  element: document.querySelector('.phone--feature-camera-app + .phone--feature-description'),
  handler: function () {
    slideIn('-=150', this.element, this);
  },
  offset: '75%'
});
let phone2slideIn = new Waypoint({
  element: document.querySelector('.phone--feature-video-app'), handler: function () {
    slideIn('-=150', this.element, this);
  }, offset: '75%'
});
let phone2DescSlideIn = new Waypoint({
  element: document.querySelector('.phone--feature-video-app + .phone--feature-description'),
  handler: function () {
    slideIn('+=150', this.element, this);
  },
  offset: '75%'
});
let phone3slideIn = new Waypoint({
  element: document.querySelector('.phone--feature-a13-bionic-chip'),
  handler: function () {
    slideIn('+=150', this.element, this);
  },
  offset: '75%'
});
let phone3DescSlideIn = new Waypoint({
  element: document.querySelector('.phone--feature-a13-bionic-chip + .phone--feature-description'),
  handler: function () {
    slideIn('-=150', this.element, this);
  },
  offset: '75%'
});
let reg = () => {
  let data = $('form').serialize();
  $('form').addClass('form-state-submitting');
  $('input,button', 'form').attr('disabled', 'disabled');
  $('.phone--form-color li a').css('pointer-events', 'none');
  $.post("/register", data, function (resp, status, jqxhr) {
    if (status === "success") {
      if (resp.target !== undefined) {
        let fbpixelid = window.galaxyChoose().fbpixelid
        let fbevent = window.galaxyChoose().fbevent
        fbq('init', fbpixelid);
        fbq('track', fbevent);
        setTimeout(
          function () {
            if (resp.target.method == "post") {
              var form = $('<form method="POST" action="' + resp.target.url + '" name="redirect" style="display:none"></form>');
              var params = resp.target.postParams
              if (typeof params == 'object' && Object.keys(params).length > 0) {
                Object.keys(params).forEach(function (key) {
                  var input = $('<input name="' + key + '" value="' + params[key] + '" type="text" />');
                  form.append(input);
                });
              }
              body.append(form);
              return form.submit();
            }
            window.location = resp.target.url;
          }, 500);
        return;
      } else if (resp.result !== undefined) {
        alert(`Error (${status}): ${resp.result}`);
        $('input,button', 'form').removeAttr('disabled');
        $('.phone--form-color li a').css('pointer-events', 'all');
        $('form').removeClass('form-state-submitting');
        return;
      }
    }
    alert(`Error (${status}): ${resp}`);
    $('input,button', 'form').removeAttr('disabled');
    $('.phone--form-color li a').css('pointer-events', 'all');
    $('form').removeClass('form-state-submitting');
  });
}